​		能用前置声明代替#include 的时候，尽量用前置声明

​		指针的大小是固定的。在32位机上是4字节，64位机上是8字节。这时编译Task1的时候不需要Date的大小，所以和Date的定义无关。

​		何时可以用前置声明代替#include

​		在这里，我自己总结了可以使用前置声明来取代包括头文件的各种情况和给出一些示例代码。

​			首先，我们为什么要包括头文件？问题的回答很简单，通常是我们需要获得某个类型的定义(definition)。那么接下来的问题就是，在什么情况下我们才需要类型的定义，在什么情况下我们只需要声明就足够了？问题的回答是当我们需要知道这个类型的大小或者需要知道它的函数签名的时候，我们就需要获得它的定义。

​		假设我们有类型A和类型C，在哪些情况下在A需要C的定义：

1.  A继承至C
2.   A有一个类型为C的成员变量 
3.  A有一个类型为C的指针的成员变量 
4.  有一个类型为C的引用的成员变量 
5.  A有一个类型为std::list<C>的成员变量
6.  A有一个函数，它的签名中参数和返回值都是类型C 
7.  A有一个函数，它的签名中参数和返回值都是类型C，它调用了C的某个函数，代码在头文件中

1.  没有任何办法，必须要获得C的定义，因为我们必须要知道C的成员变量，成员函数。
2.  需要C的定义，因为我们要知道C的大小来确定A的大小，但是可以使用Pimpl惯用法来改善这一点，详情请看Hurb的Exceptional C++。
3.  4.不需要，前置声明就可以了，其实3和4是一样的，引用在物理上也是一个指针，它的大小根据平台不同，可能是32位也可能是64位，反正我们不需要知道C的定义就可以确定这个成员变量的大小。

5.  不需要，有可能老式的编译器需要。标准库里面的容器像list， vector，map，
    在包括一个list<C>，vector<C>，map<C, C>类型的成员变量的时候，都不需要C的定义。因为它们内部其实也是使用C的指针作为成员变量，它们的大小一开始就是固定的了，不会根据模版参数的不同而改变。
6.  不需要，只要我们没有使用到C。
7.  需要，我们需要知道调用函数的签名。



​		C++中将”接口与实现分离“的两个重要目的就是”降低文件间的编译依存关系“和”隐藏对象的实现细节“，都是考虑到C++的高效和安全。而实现这一目的的关键技术就是”Pimpl模式（pointer to implementation）”，也即是”把一个类所有的实现细节都“代理”给另一个类来完成，而自己只负责提供接口“，而实现”Pimpl模式”的关键又是“依赖对象的声明（declaration）而非定义（definition）”，这样就引出了今天的话题：为什么通过“依赖对象的声明”可以实现Pimpl模式“，进而实现”接口与实现分离“？我们一步步来抽丝剥茧吧！

 

什么是“前置声明”？

 

​    ”前置声明“和”include“就是一对冤家！我们先看一个例子：

前置声明”的作用？

 

​    “前置声明”的作用有2：

​    （1）解决两个class的相互依赖问题，也就是两个文件相互include，减少头文件的包含层次。比如以上的几个例子！

​    （2）降低文件之间的“编译依存关系”，从第一个例子我们看到，当我们在类A使用类B的前置声明时，我们修改类B时，只需要重新编译类B，而不需要重新编译a.h的（当然，在真正使用类B时，必须包含b.h）。如果使用include的话，一个文件改变，所有include这个文件的文件都得重新编译，这是非常耗时的！

​    （3）通过“前置声明”可以实现“接口与实现分离“。我们将需要提供给客户的类分割为两个class：一个只提供接口，另一个负责实现！

 

C++标准其实是不支持enum的前置声明的，原因在于标准规定Enum的size是由其所容纳的值所确定的，所以在看到所有的值之前，编译器是无法确定其存储的

​		头文件包含其实是一想很烦琐的工作，不但我们看着累，编译器编译的时候也很累，再加上头文件中常常出现的宏定义。感觉各种宏定义的展开是非常耗时间的，远不如自定义函数来得速度。我仅就不同头文件、源文件间的句则结构问题提出两点原则，仅供参考：


　　第一个原则应该是，如果**可以不包含头文件，那就不要包含了。这时候前置声明可以解决问题。**如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知。


　　第二个原则应该是，**尽量在CPP文件中包含头文件，而非在头文件中。**假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类B的前置声明并便宜成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件)。