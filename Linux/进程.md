## 进程

每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是`task_struct`结构体。它里面包含了：

*   进程id。系统中每个进程有唯一的id，在c语言中用`pid_t`类型标识，其实就是一个非负整数。
*   进程的状态，有运行、挂起、停止、僵尸等状态。
*   进程切换时需要保存和恢复的一些CPU寄存器。
*   描述虚拟地址空间的信息
*   描述控制终端的信息。
*   当前工作目录。
*   umask掩码。
*   文件描述符，包含很多指向file结构体的指针。
*   和信号相关的信息。
*   用户id和组id。
*   控制终端、Session和进程组。
*   进程可以使用的资源上限。

### fork和exec

​		fork的作用是根据一个现有的进程复制出一个新进程，原来的进程称为父进程(Parent Process),新进程称为子进程(Child Process)。在Shell下输入命令可以运行一个程序，是因为Shell进程在读取用户输入的命令后会调用fork复制出一个新的Shell进程，然后新的Shell进程调用exec执行新的程序。

![](..\picture\捕获.PNG)

### 环境变量

exec系统调用执行新程序时会把命令行参数和环境变量表传递给main函数，他们在整个进程地址空间中的位置如下图所示。

![](..\picture\进程地址空间.PNG)

和命令行参数argv类似，环境变量也是一组字符串，如下图所示：

![](..\picture\环境变量.PNG)

​		libc中定义的全局变量environ指向环境变量表，environ没有包含任何头文件中，所以在使用中要用ectern声明。

```
![环境变量执行](C:\Users\dell\Desktop\Learning-Notes\picture\环境变量执行.PNG)#include <stdlib.h>
#include <stdio.h>

int main(int argc, char const *argv[])
{
	extern char **environ;
	int i;
	for(i=0;environ[i]!=NULL;i++)
	{
		printf("%s\n",environ[i] );
	}
	return 0;
}
```

![](..\picture\环境变量执行.PNG)

一些比较重要的环境变量的含义如下：

**PATH**

可执行文件的搜索路径。ls命令也是

**SHELL**

当前shell，它的值通常是`/bin/bash`.

**TERM**

当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面可以显示汉字，而字符终端不行。

**LANG**

语言和local，决定了字符编码以及时间、货币等信息的显示格式

**HOME**

当前用户主目录的路径，很多程序需要在主目录下保存配置文件，是好的每个用户在运行该程序的时候有一套自己的配置





为了在程序中获取某一name的value，可以用以下函数：

```
char* getenv(const char* name);
```

`getenv`返回的值是指向value的指挥指挥很，若未找到则为NULL。

修改环境变量可以用以下函数：

```
int setenv(const char* name,const char* value,int rewrite);
void unsetenv(const chhar* name);
```

`setenv`函数若成功则返回为0，若出错则返回非0。并且将环境变量name的值设置为value。如果存在环境变量name，那么：

*   若rewrite非0，则覆盖原来的定义。
*   若rewrite为0，则不覆盖原来的定义，也不返回错误。

`unsetenv`删除name的定义。即使name没有定义也不返回错误。

### 进程控制

**fork函数**

```
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

​		fork调用失败则返回-1；调用成功在子进程中返回值为0，在父进程中返回的则是子进程的id。fork函数的特点概括起来就是”调用一次，返回两次“，在父进程中调用一次，在父进程和子进程中各返回一次。

​		fork这样做是有道理的，fork在子进程中返回0，子进程仍可以调用getpid得到自己的id，也可以通过getppid函数得到父进程的id。在父进程中可以用getpid得到自己的进程id，然而要得到子进程的id，只有将fork的返回值记录下来。

​		fork的另一个特性是所有的由父进程打开的描述符都被复制到子进程中。父子进程中相同编号的文件描述符在内核中指向同一个file结构体。

实例：

```
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char const *argv[])
{
	
	pid_t pid;
	char *message;
	int n;
	pid=fork();
	if(pid<0)
	{
		perror("fork failed!\n");
	}
	if(pid==0)
	{
		message="This is the child\n";
		n=6;
	}
	else
	{
		message="This is the parent\n";
		n=3;
	}
	for (;n>0;n--)
	{
		printf("%s\n",message );
		sleep(1);
	}
	return 0;
}
```

这个程序的执行流程如下：

1.  父进程初始化。
2.  父进程调用fork，这是一个系统调用，因此进入内核。
3.  内核根据父进程复制出一个子进程，父进程和子进程的PCB信息相同，用户态代码和数据也相同。因此，子进程现在的状态看着和父进程一样，做完了初始化，刚调用fork进入内核，还没有从内核返回。
4.  现在有两个一模一样的进程都调用了fork进入内核等待从内核返回（实际上内核只调用了一次），是父进程先返回还是子进程先返回，还是这两个进程都等待，这都不一定，取决于内核。
5.  如果某个时候父进程被调度执行了，从内核返回后，保存在变量pid中的返回值是子进程的id，是一个大于0的整数，因此执行else后面的代码。
6.  如果某个时刻子进程被调度执行，从内核返回后就从fork返回，变量pid为0。因此执行属于自己的分支。fork调用把父进程的数据复制一份给子进程，但此后二者互不影响。
7.  父进程每打印一条消息就沉睡一秒，这是时候内核调用别的进程执行，这时候子进程有可能被调度到，就开始执行子进程，然后也沉睡一秒，这样的结果就是父子进程交替打印。但是也不一定，取决于内核调度算法。
8.  程序是在shell下执行的，所以Shell进程是父进程的父进程。父进程运行的时候Shell进程处于等待状态。当父进程终止时Shell进程认为命令执行结束了，于是打印shell提示符，而这时子进程还没有执行完，所以子进程的消息打印到了Shell提示符的后面。

用gdb调试多进程的时候会遇到困难，gdb只能跟踪一个进程(默认跟踪父进程)，而不能同时跟踪多个进程，但是可以设置gdb在fork之后跟踪父进程还是子进程。

```
set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程
set follow-fork-mode parent 则是跟踪父进程
```



## exec函数

用fork创建子进程后执行的是和父进程相同的程序（但是有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。

有六种exec函数，

```
#include <unistd.h>

int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ...,char * const envp[] );
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],char *const envp[]);
```

​		这些函数如果调用成功则加载新的程序从启动代码开始执行，不在返回，如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值。

​		不带p（表示path）的exec函数第一个参数必须是程序的相对路径和绝对路径，例如"/bin/ls"或"./a.out"，而不能是“ls”或“a.out”,对于带p的函数：

*   如果参数中包含/，则将其视为路径名。
*   否则视为不带路径的程序名，在PATH环境变量的目录列表中搜索这个程序。



​		带有l(list)的exec函数和要求将新程序的每个命令行参数都当作一个参数传给他，命令行参数的个数是可变的，因此函数原型中有`...`，`...`中的最后一个可变参数应该是`NULL`，起sentinel的作用。对于带有字母v的函数，则应该首先构造一个指向各参数的指针数组，然后将该数组的首地址当作参数传给他，数组的最后一个指针也应该是NULL，就像main函数的argv参数或者环境变量表一样。

​		对于以e结尾的exec函数，可以把一份新的环境变量表传给他，其他的exec函数仍使用当前的环境变量表执行新程序。

事实上，只有`execve`是真正的系统调用，其他五个函数最终都调用`execve`

![](..\picture\微信截图_20201002191629.png)

