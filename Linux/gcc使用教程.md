GCC(GNU Compiler Collection, GNU编译器套件),是由GNU开发的编程语言编译器。GCC的官网是[http://gcc.gnu.org](http://gcc.gnu.org)。

GCC是一个编译器套件，包含很多软件包，主要软件包如表：

![](..\picture\微信截图_20200506203015.png)

gcc支持多种语言编译，下表列出了用于编译和链接C/C++程序所需要的文件扩展名。

![](..\picture\微信截图_20200506203052.png)

## gcc基本使用

```
gcc [选项][文件名]
```

例如：

```
gcc hello.c -o hello
```

也可以不用指定-o，直接得到a.out文件。

### gcc编译过程

从hello.c到hello.o文件，应当经历hello.i,hello.s,hello.o，最后才得到hello(a.out)文件，分别经历预处理，编译，汇编，和链接4个步骤，整个过程如下：

![](..\picture\微信截图_20200506203630.png)

这4步的大致工作内容如下：

*   预处理：C编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等。
*   编译：将预处理得到的源代码文件，进行“翻译替换”，产生出机器语言的目标程序，得到机器语言的汇编文件。
*   汇编：将汇编代码翻译成机器码，但还是不可以运行。
*   链接：处理可重定位文件，把各种符号引用和符号定义转换成可执行文件中的合适信息，通常是虚拟地址。

以hello.c为例：

在gcc命令加上-E参数，可以得到与处理文件。

```
gcc -E hello.c -o hello.i
```

![](..\picture\微信截图_20200506204736.png)

在gcc命令后加上-S参数，可以将hello.i编译成hello.s。

```
gcc -S hello.s
```

![](..\picture\微信截图_20200506204916.png)

-c参数可以进行汇编，得到机器码。

```\
gcc -c hello.s
```

![](..\picture\微信截图_20200506205134.png)

然后就可以进行最后一步，链接,。

```
gcc hello.o
```

如果不指定文件名，默认得到a.out。

![](..\picture\微信截图_20200506205511.png)

可以通过-o指定新的文件名。

![](..\picture\微信截图_20200506205405.png)

链接可以分为动态链接和静态链接：

*   动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。linux下的动态链接库实际是共享文件目标，一般是.so文件，类似与Windows下的.dll文件。
*   静态链接使用静态库进行链接，生成的程序包含运行所需要的全部库，可以直接运行，体积较大。linux下静态库是汇编产生的.o文件的集合，一般以.a文件形式出现。

gcc默认是动态链接，加上-static参数则是采用静态链接。

![](..\picture\微信截图_20200507100845.png)

可以看到，静态链接生成的文件比动态链接生成的大了很多。

### gcc编译控制选项

gcc有很多编译控制选项，使得gcc可以根据不同的参数进行不同的编译处理。

![](..\picture\微信截图_20200507102129.png)

![](..\picture\微信截图_20200507102145.png)

在编译的时候加上-v参数，编译将会显示详细的编译过程。

![](..\picture\微信截图_20200507103031.png)

通过-I dirname参数可以将dirname指定的目录添加到头文件搜索目录列表中，编译器在包含头文件的时候就会搜索指定的路径。

### 库文件的用法

库文件的用法有两种，一种是在编译列表中写出库文件全名（可带路径）。如下例：

```
gcc hello.c libFOO.a OR gcc hello.c libFOO.so
```

另一种方式是分别用“-L”指定库文件路径，并用“-l”参数加上FOO名称即可，无需库文件全名：

*   将libFOO.so所在目录添加到系统库文件搜索路径中。在编译的时候通过“-L dirname”完成。

```
gcc hello.c -L /home/fengjt/hello
```

*   指定链接库文件名。在编译的时候可通过"-lFOO"参数将libFOO.so链接到应用中：

```
gcc hello.c -L /home/fengjt/hello -lFOO
```

### 优化等级

gcc优化等级由高到低分别是-O0,-O1,-O2和-O3。优化等级越高，编译时间越长。但是不同等级的优化，所产生的代码尺寸、执行效率方面也是不同的。

还有一个在嵌入式系统中常用的优化等级-Os。-Os相当于-O2.5，使用了-O2的优化部分选项，同时对代码尺寸进行优化。

### 调试信息

如果开启了优化选项，得到的代码是没有任何调试信息的，对于需要调试的程序，必须在编译的时候保留调试信息，关闭优化选项，打开"-g"调试选项。

### 创建静态库

静态库是.o文件的集合，这些.o文件是编译器按照常规方法生成的，在Linux下也称文档，用ar工具管理。

先将文件编译成.o文件

```
gcc -c hello.c hello2.c
```

接着用ar命令创建一个库文件。输入下列命令：

```
ar -r lib.a hello.o hello2.o
```

### 创建共享库

共享库也是目标文件的集合，但是这些文件是由编译器按照特殊方式生成的。对象模块的每个地址(函数调用和变量引用)都是相对地址，允许在运行时被动态加载和运行。

和静态库一样，先编译生成.o文件。

```
gcc -c -fpic hello.c hello2.c
```

这里和静态库不同的地方在于加入了-fpic参数，表示生成的模块是可重定位的，pic表示位置独立代码。

编译完成，然后再用下列命令生成共享库：

```
gcc -shared hello.o hello2.o -o lib.so
```

编译完成，得到共享库文件lib.so。

也可以把两条命令合成一条：

```
gcc -fpic -shared hello.c hello2.c -o lib.so
```



在加载共享库的时候，会报错：

![](..\picture\微信截图_20200509112403.png)

这是因为链接器工作于链接阶段，工作时需要-L和-l提供路径。但是动态链接器工作于程序运行阶段，工作时需要提供动态库所在的目录位置。

解决方法：

*   通过环境变量：export LD_LIBRARY_PATH=动态库路径

![](..\picture\微信截图_20200509112925.png)

但是这个只是临时生效，重启终端环境变量失效。

*   永久生效，写入终端配置文件。

```
vim ~/.bashrc
在里面写入export LD_LIBRARY_PATH=动态库路径 保存
重启终端，让修改的.bashrc生效
执行./a.out
```

*   拷贝自定义库到/lib   标准c库所在的目录位置。

    