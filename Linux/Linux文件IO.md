# Linux文件I/O

Linux下的输入输出I/O，设计成“一切皆文件”，把各种各样的输入输出当成文件来操作。并且Linux把大部分系统资源当作文件呈现给用户，用户只需按照文件I/O的方式，就能完成数据的输入输出。Linux文件，按其代表的具体对象，可分类为：

*   普通文件，即一般意义的文件、磁盘文件。
*   设备文件，代表的是系统中的一个具体的设备。
*   管道文件、FIFO文件，一种特殊的文件，常用于进程间通信。
*   套接字（socket）文件，主要用在网络通信方面。

## 文件描述符

文件描述符（fd）是进程中代表某个文件的整数。有效的文件描述符是一个非零的正整数。它实际上是进程文件描述符表的索引。文件描述符表是用来保存她所打开的文件信息、由操作系统维护的一个登记表。文件描述符的取值范围，反映了文件描述符表的大小，表示这个进程最多可以打开多少个文件。可通过命令`ulimit -n`查看这个数值的大小。

对于内核而言，进程所打开的文件都是由文件描述符引用。当进程打开一个现存文件或建一个新文件时，内核返回一个文件描述符给进程。通常，文件描述符0，1，2在进程启动时已被占用，代表进程在启动过程中打开的文件。文件描述符0，1，2代表的文件如下。

| 文件描述符 |       含义       |
| :--------: | :--------------: |
|     0      | 标准输入(stdin)  |
|     1      | 标准输出(stdout) |
|     2      | 标准错误(stderr) |

## 常用文件I/O操作和函数

### open

进行I/O操作时，要先打开对应的文件，可调用open()函数打开文件，他返回的文件描述符fd代表打开的文件，后续操作通过引用文件描述符fd来表示对该文件的操作，open()函数定义如下：

```
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname,int flags);
int open(const char *pathname,int flags,mode_t mode);
```

`pathname`参数是要打开或创建的文件名，既可以时相对路径也可以是绝对路径。

`flags`参数有一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来，所以这些常数的宏定义都以O_开头。

必选项：以下三个常数中必须指定一个，且仅允许指定一个。

| 打开文件标志 |                       含义                       |
| :----------: | :----------------------------------------------: |
|   O_RDONLY   |    以只读方式打开文件，与O_WRONLY和O_RDWR互斥    |
|   O_WRONLY   |    以只写方式打开文件。与O_RDONY和O_RDWR互斥     |
|    O_RDWR    | 以可读可写方式打开文件，与O_WRONLY和O_RDONLY互斥 |

以下选项可以同时指定0个或多个，和必须按位或起来作为flags参数：

| 打开文件标志 |                             含义                             |
| :----------: | :----------------------------------------------------------: |
|   O_CREAT    |             如果要打开的文件不存在，则创建该文件             |
|    O_EXCL    | 该标志与 O_CREAT 共同使用时，会去检查文件是否存在，若文件不存<br/>在则创建该文件，否则将导致打开文件失败。此外，打开文件链接时，<br/>使用该标志将导致失败 |
|   O_NOCTTY   | 如果要打开的文件为终端设备时，则不把终端设备当成进行控制终端 |
|   O_TRUNC    | 若文件存在且以可写方式打开，此标志会清除文件内容，并将其长度置<br/>为 0 |
|   O_APPEND   | 读写文件都从文件的尾部开始，所写入的数据会以附加的方式加入到文<br/>件末尾 |
|  O_NONBLOCK  | 以不可阻塞方式打开文件，也就是不管有无数据需要读写或者等待，都<br/>会立即返回 |
|   O_NDELAY   | 以不可阻塞方式打开文件，也就是不管有无数据需要读写或者等待，都<br/>会立即返回(已过时，由 O_NONBLOCK 替代) |
|    O_SYNC    |                      以同步方式打开文件                      |
|  O_NOFOLLOW  |  如果文件名所指向的文件本身为符号链接，则会导致打开文件失败  |
| O_DIRECTORY  |   如果文件名所指向的文件本身并非目录，则会导致打开文件失败   |

注意open函数与C标准库的fopen函数的区别：

*   以可写的方式fopen一个文件时，如果文件不存在会自动创建，而open一个文件时必须明确指定O_CREAT才会创建文件，否则文件不存在就会出错返回。
*   以w或w+方式fopen一个文件时，如果文件已存在就截断为0字节，而open一个文件时必须明确指定O_TRUNC才会截断文件，否则直接在原来的数据上改写。

`mode`参数指定创建文件时的权限，可以使用八进制数来表示新文件的权限，也可以采用`<fcntl.h>`中定义的符号常量，如下表所示，当打开已有文件时，可以忽略这个参数。

| 符号常量 |  值   |           含义           |
| :------: | :---: | :----------------------: |
| S_IRWXU  | 0x700 | 所属用户读、写和执行权限 |
| S_IRUSR  | 0x400 |      所属用户读权限      |
| S_IWUSR  | 0x200 |      所属用户写权限      |
| S_IXUSR  | 0x100 |     所属用户执行权限     |
| S_IRWXO  | 0x007 | 其他用户读、写和执行权限 |
| S_IROTH  | 0x004 |      其他用户读权限      |
| S_IRWXG  | 0x070 |  组用户读、写和执行权限  |
| S_IRGRP  | 0x040 |       组用户读权限       |
| S_IWGRP  | 0x020 |       组用户写权限       |
| S_IXGRP  | 0x010 |      组用户执行权限      |
| S_IWOTH  | 0x002 |      其他用户写权限      |
| S_IXOTH  | 0x001 |     其他用户执行权限     |

**注意，文件权限由`mode`参数和当前进程的`umask`掩码共同决定。**

### close

文件I/O操作完成后，应该调用`close`函数关闭打开的文件。`close`函数的定义如下：

```
#include <unistd.h>
int close(int fd);
```

如果文件顺利关闭，返回0，否则返回-1，同时设置ERRNO报告具体的错误原因。参数fd是打开文件时返回的文件描述符。

当一个文件被打开多次时，比如被多个进程同时打开，或在同一个进程中被打开多次，
每打开一次，该文件内部的引用计数就增加 1，对该文件每调用一次 close()，文件引用计数
则减 1，当计数值减到 0 时，内核才关闭该文件。当进程终止时，内核会回收进程资源，也
按上述规则关闭进程打开的全部文件。

由 open 返回的文件描述符一定是该进程尚未使用的最小描述符。由于程序启动时自动打开文件
描述符0、1、2，因此第一次调用 open 打开文件通常会返回描述符3，再调用 open 就会返回4。可
以利用这一点在标准输入、标准输出或标准错误输出上打开一个新文件，实现重定向的功能。

### creat

`open`的参数flags，当设置了O_CREAT标志时，可以创建一个新文件。但是也可以用另外一个函数`creat`创建新文件，函数定义如下：

```
#include <fcntl.h>
int creat(const char* pathname,mode_t mode);
```

参数pathname和mode与`open`函数相同。`open`函数与`creat`函数都能创建新文件，他们对已有文件的细节不同：

*   `creat`创建文件时，如果文件已经存在，则会把已存在的文件清空，长度截为0，然后返回对应的文件描述符，如果文件不存在，则直接创建，然后返回创建文件的描述符。
*   当`open`的参数flags设置了O_CREAT时，如果文件已经存在，则直接打开并返回文件描述符。如果文件不存在，则创建新文件，然后返回对应的文件描述符。