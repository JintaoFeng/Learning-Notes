# Linux中fork子进程后再exec新程序时文件描述符的问题？

fork后，我们会调用exec执行另一个程序，此时会用全新的程序替换子进程的正文，数据，堆和栈，那这样的话子进程的文件描述符表所占的内存也自动释放了吧，为什么还会存在是否要关闭子进程的文件描述符一说？

1. fork后子进程将复制父进程的数据段、BSS段、代码段、堆空间、栈空间和**文件描述符。**

3. 在执行exec系列函数时，默认情况下，新代码可以使用在父进程中fork前打开的文件描述符，即执行exec系列函数时，并不关闭进程原来打开的文件。

所以，使用exec执行新的程序时，仍然可以使用原来的文件。那么有没有什么办法关闭呢？答案是有的：

1. 如果子进程执行的新程序为自己编译后的程序，可以在子进程程序中用循环关闭从0到NOFILE的文件描述符。NOFILE是一个系统宏定义，不同的系统有不同的值。

2. 在父进程中使用fcntl函数设置文件描述符的`CLOEXEC`项：`fcntl(fd,F_SETFD,FD_CLOEXEC)`。`FD_CLOEXEC`是`fd close on exec`的缩写，设置了此项后在执行exec系列函数时，将自动关闭设置了此项的fd。

