# TCP协议

![img](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/640?token=AKEQGWLRI6M53UZJKUONE627ZL32Q)

## TCP和UDP的区别

TCP是一个面向连接的、可靠的、基于字节流的传输层协议。

UDP是一个面向无连接的传输层协议。

和UDP相比，TCP有三大核心特性：

1.  面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP需要三次握手建立连接，而UDP没有相应建立连接的过程。
2.  可靠性。TCP花了非常多的功夫保证连接的可靠，这个可靠体现在一个事有状态，一个是可控制。

TCP会精准记录哪些数据发送了，哪些数据被接受了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这就是有状态。

当意识到丢包了或者网络环境不佳，TCP会根据具体的情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。

相应的，UDP是无状态的，不可控的。

3.  面向字节流。UDP的数据传输是基于数据报的，这是因为仅仅只是继承了IP层的特性，而TCP为了维护状态，将一个个IP包变成了字节流。

## TCP三次握手的过程？为什么是三次而不是两次、四次。

TCP三次握手，主要是为了确认双方的发送和接受能力。于是便会有了下面的三次握手过程。

![image-20201205110839687](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205110839687.png?token=AKEQGWM6JREPRQPCCVPNLHC7ZL47O)

最开始双方都是处于CLOSED状态，然后服务端开始监听某个端口，进入了LISTEN状态。

然后客户端主动发起连接，发送SYN，自己变成了SYN-SENT状态。

服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-SEND.

之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态。服务端收到ACK后，也变成了ESTABLISHED状态。

需要注意的是，SYN是需要消耗一个序列号的，下次发送对应的ACK序列号要加1.

**凡是需要对端确认的，一定消耗TCP报文的序列号**。

SYN需要对端的确认，而ACK并不需要，因此SYN小号一个序列号而ACK不需要

### 为什么不是两次

根本原因：无法确认客户端的接收能力。

如果是两次，你现在发了SYN报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP以为这是丢了包，于是重传，两次握手建立好了连接。

看似没有问题，但是连接关闭后，如果滞留在网路中的包到达了服务端，这时候由于两次握手，服务端只要接收然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。



### 为什么不是四次

三次握手已经可以确认双方的发送和接收能力，四次也可以，但是用处不大。

### 三次握手过程中可以携带数据吗

第三次握手的时候，可以携带。前两次握手不能携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么它只需要在第一次握手中的SYN报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。

第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

### 同时打开会怎样

如果双方同时发SYN报文，状态变化会是怎样的？
![image-20201205113158607](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205113158607.png?token=AKEQGWOFWMBWIKFO5KB7NYS7ZL7XA)

在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人碰上了。

发完SYN，两者的状态都变成了SYN-SENT。

在各自收到对方的SYN后，两者状态都变为SYN-REVD。

接着会回复对应的ACK+SYN，这个报文在对方接受后，两者状态一起变为ESTABLISHED。

## TCP四次挥手的过程

![image-20201205113518321](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205113518321.png?token=AKEQGWKP7K4Y2CGHJRFP6HK7ZMADM)

刚开始双方都处于ESTABLISHED状态。

客户端要断开了，向服务器发送FIN报文，在TCP报文中的位置如下图：

![image-20201205115609698](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205115609698.png?token=AKEQGWICGQAQUFOVU2L55O27ZMCRU)

发送后客户端变成了FIN-WAIT-1状态。注意，这时候客户端同时也变成了half-close状态，即无法向服务端发送报文，只能接收。

服务端接收后向客户端确认，变成了CLOSED-WAIT状态。

客户端接收到了服务端的确认，变成了FIN-WAIT2状态。随后，服务端向客户端发送FIN，自己进入LAST-ACK状态。客户端接收到服务端发来的FIN后，自己变成了TIME-WAIT状态然后发送ACK给服务端。

注意，这时候客户端需要等待足够长的时间，具体来说，是2个MSL(报文最大生存时间)，在这段时间内如果客户端没有收到服务端的重发请求，那么表示ACK成功到达，挥手结束，否则客户端重发ACK。

### 等待2MSL的意义

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法就是等服务器发来的数据包都死翘翘再启动新的应用。

那么，为什么是2MSL。

*   一个MSL确保四次挥手中主动关闭方最后的ACK最终能达到对端。
*   一个MSL确保对端没有收到ACK重传的FIN报文可以到达。

### 为什么是四次挥手而不是三次

因为服务端在接收到FIN，往往不会立即返回FIN，必须等到服务端所有的报文都发送完毕了，才发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造就了四次挥手。

如果是三次挥手等于说服务端将ACK和FIN的发送合为一次挥手，这个时候长时间的延迟会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。

### 同时关闭会怎样

如果客户端和服务端同时发送FIN，状态会如何变化？

![](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205121049489.png?token=AKEQGWJAWDT65OJE6IXGXIK7ZMEIS)

## 半连接队列和SYN Flood攻击的关系

三次握手前，服务端的状态从CLOSED变为LISTEN,同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。

### 半连接队列

当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。

### 全连接队列

当客户端返回ACK，服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个TCP维护队列，也就是全连接队列。

### SYN Flood攻击原理

SYN Flood属于典型的DoS/DDoS攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的IP地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果：

1.  处理大量的SYN包并返回对应的ACK，势必有大量链接处于SYN_RCVD状态，从而沾满整个半连接队列，无法处理正常的请求。
2.  由于是不存在的IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，知道耗尽服务端的资源。

### 如何应对SYN Flood攻击

1.  增加SYN连接，也就是增加半连接队列的容量。
2.  减少SYN+ACK重试次数，避免大量的超时重发。
3.  利用SYN Cookie技术，在服务端收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie合法之后才分配连接资源。

## TCP报文头部的字段

报文头部结构如下：

![image-20201205185256633](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205185256633.png)

### 源端口 目标端口

如何标识一个链接？答案是TCP连接的四元组--源IP、源端口、目标IP和目标端口。

因为在IP层已经处理了IP，所以TCP报文hi需要记录两者的端口就可以。

### 序列号

即sequence number，指的是本报问字段第一个字节的序列号。

从图中可以看出，序列号是一个长为4字节，也就是32位的无符号整数，标识范围为0~2^32-1.如果到达最大值了后就循环到0.

序列号在TCP通信中有两个作用：

1.  在SYN报文中交换彼此的初始序列号。
2.  保证数据包按正确的顺序组装。

### ISN

即Initial sequence Number，在三次握手的过程当中，双方会用SYN报文来交换彼此的ISN。

ISN并不是一个固定的值，而是每4ms加一，溢出则回0，这个算法使得猜测ISN变得很困难。

如果ISN被攻击者预测到，要知道源IP和源端口号都是很容易伪造的，当攻击者猜测ISN之后，直接伪造一个RST后，就可以强制连接关闭的。

而动态增长的ISN大大提高了猜测ISN的难度。

### 确认号

即ACK。用来告知对方下一个期望接受的序列号，小于ACK的所有字节已经全部接收到。

### 标记位

常见的标记位有 SYN、ACK、FIN、RST、PSH。

SYN和ACK已经在上文说过了，后三个解释如下：FIN即finish，表示发送方准备断开连接。

RST:即reset，用来强制断开连接。

PSH：即push。告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。

### 窗口大小

占用两个字节，也就是16位，但实际上是不够用的。因此TCP引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在0~14，比例因子可以将窗口的值扩大为原来的在2^n.

### 校验和

占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP直接丢弃，等待重传。

### 可选项

可选项的格式如下：

![image-20201205190715020](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205190715020.png)

常用的可选项有以下几个：

*   TimeStamp：TCP时间戳。
*   MSS：指的是TCP允许的从对方接受的最大报文段。
*   SACK：选择确认选项。
*   Window Scale：窗口缩放选项。

## TCP快速打开的原理(TFO)

### TFO流程

**首轮三次握手**

首先客户端发送SYN给服务端，服务端接收到。

注意，现在服务端不是立刻回复SYN+ACK，而是通过计算得到一个SYN Cookie，将这个Cookie放到TCP报文的Fast Open选项中，然后才返回给客户端。

客户端拿到这个Cookie的值缓存下来。后面正常完成三次握手。

首轮三次握手完成，后面的三次握手就不一样了。

**后面的三次握手**

在后面的三次握手中，客户端会将之前缓存的Cookie、SYN和HTTP请求发送给服务端，服务端验证了Cookie的合法性，如果不合法直接丢掉，反之正常返回SYN+ACK。

重点是。现在服务端能向客户端发HTTP响应了。三次握手还没建立，仅仅验证了Cookie的合法性，就可以返回HTTP的响应了。

当然，客户端的ACk还得正常传过来。

![image-20201205191647439](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205191647439.png)

注意：客户端最后握手的ACK不一定要等服务端的HTTP响应到达才发送，两个过程没有任何关系。

### TFO的优势

TFO的优势并不在与首轮的三次握手，而在于后面的握手，在拿到客户端的Cookie并验证通过后，可以直接返回HTTP响应，充分利用了1个RTT的时间提前进行数据传输。

## TCP报文中时间戳的作用

timestamp是TCP报文首部的一个可选项，一共占10个字节，格式如下：

```
kind(1字节)+length(1字节)+info(8字节)
```

其中kind=8，length=10，info有两部分组成：timestamp和timestamp echo，各占四个字节。

TCP的时间戳主要解决两大问题：

*   计算往返时间RTT
*   防止序列号的回绕问题。

### 计算往返时延RTT

在没有时间戳的时候，计算RTT会遇到的问题如下图所示：

![image-20201205192332879](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205192332879.png)

如果以第一次发包为开始时间的话，就会出现如左图的问题，RTT明显偏大，开始时间应该采用第二次的：如果一第二次发包为开始时间的话，就会导致右图的问题，RTT明显偏小，开始时间应该采用第一次发包的。

实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。

那这个时候引入时间戳就很好解决了这个问题。

比如现在a向b发送一个报文s1，b向a回复一个含ACK的报文s2，那么：

*   a向b发送的时候，timestamp中存放的内容就是a主机发送时的内核时刻ta1.
*   b向a回复s2报文的时候，timestamp中存放的内容就是b主机的时刻tb，timestamp echo字段为从s1报文中解析出来的ta1.
*   a收到b的s2报文之后，此时a主机的内核时刻是ta2，而在s2报文中的timestamp echo选项中可以得到ta1，也就是s2对应的报文最初的发送时刻。然后采用ta2-ta1就得到了RTT的值。

### 防止序列号回绕问题

序列号的范围其实是在0~ 2^32-1，为了方便演示，我们缩小一下这个区间，假设范围是0~4，那么到达4的时候会回到0.

| 第几次发包 | 发送字节 | 对应序列号 |          状态           |
| :--------: | :------: | :--------: | :---------------------: |
|     1      |   0-1    |    0-1     |        成功接收         |
|     2      |   1-2    |    1-2     |      滞留在网络中       |
|     3      |   2-3    |    2-3     |        成功接收         |
|     4      |   3-4    |    3-4     |        成功接收         |
|     5      |   4-5    |    0-1     | 成功接收，序列号从0开始 |
|     6      |   5-6    |    1-2     |         ？？？          |

假设在第6次的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为1~2的数据包了，怎么区分谁是谁呢？这个时候就产生了序列号回绕问题。

那么用timestamp就能很好的解决这个问题，因为每次发包的时候都是将法宝机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。

## TCP的超时重传时间是如何计算的

TCP的超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。

这个重传间隔也叫做超时重传时间（RTO），他的计算跟上一节的RTT相关。这里介绍两种方法，一个是经典方法，一个是标准方法。

### 经典方法

经典方法引入了一个新的概念--SRTT，即平滑往返时间，每产生一次新的RTT，就根据一定的算法对SRTT进行更新，具体而言，计算方式如下：
$$
SRTT=(\alpha * SRTT)+((1-\alpha)*RTT)
$$
其中，$\alpha$是平滑银子，建议值是0.8，范围是0.8~0.9.

拿到SRTT，我们就可以计算RTO的值：
$$
RTO=min(ubound,max(lbound,\beta *SRTT))
$$
$\beta$是加权因子，一般为1.3~2.0,lbound是下界，ubound是上届。

其实这个算法过程还是很简单的，但是也存在一定的局限，就是在RTT稳定的地方表现还可以，而在RTT变化较大的地方就不行了，因为平滑因子$\alpha$的范围是0.8~0.9，RTT对于RTO的影响太小了。

### 标准方法

为了解决经典方法对对于RTT变化不敏感的问题，后面又引出了标准方法。

分三步：

1.  计算SRTT，公式如下：

$$
SRTT=(1-\alpha)*SRTT+\alpha*RTT
$$

这个时候的$\alpha$跟经典方法中的$\alpha$不一样了，建议取值1/8，也就是0.125.

2.  计算RTTVAR这个中间变量

$$
RTTVAR=(1-\beta)*RTTVAR+\beta *(|RTT-SRTT|)
$$

$\beta$建议值为0.25，这个值是这个算法中出彩的地方，也就是说，它记录了最新的RTT与当前的SRTT之间的差值。

3.  计算最终的RTO:

$$
RTO=\mu*SRTT+\sigma*RTTVAR
$$

$\mu$建议值取1，$\sigma$建议取值4.

这个公式在SRTT的基础上加上了最新RTT与他的偏移，从而很好的赶制了RTT的变化，这种算法下，RTO与RTT变化的差值关系更加密切。

## TCP的流量控制

对于发送端和接收端而言，TCP需要把发送的数据放到发送缓存区，将接收到的数据放入接收缓存区。

而流量控制所要作的事，就是通过接收缓存区的大小，控制发送端的发送，如果对方的接收缓存区满了，就不能再继续发送了。

首先，我们了解一下滑动窗口。

### TCP滑动窗口

TCP的滑动窗口分为两种：发送窗口和接收窗口

**发送窗口**

发送端的滑动窗口结构如下：

![image-20201205200439139](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205200439139.png)

发送窗口就是图中被框住的范围。SND即send，WND即Windows，UNA即unacknowledged，表示未被确认，NXT即next，表示下一个发送的位置。

**接收窗口**

接收端的窗口结构如下：

![image-20201205200643709](https://raw.githubusercontent.com/JintaoFeng/Picture/main/img/image-20201205200643709.png)

REV即receive，NXT表示下一个接收的位置，WND表示接收窗口的大小。

### 流量控制过程

首先双方三次握手，初始化各自的窗口带大小，均为200个字节。

假如当前发送端给接收端发送100个字节，那么此时对于发送端而言，SEND、NXT当然要右移100个字节，也就是说当前的可用窗口减少了100个字节。

现在这100个字节到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理40个字节，剩下的60个字节被留在了缓冲队列中。

注意，此时接收端的情况是处理能力不够用了，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小60个字节，由200个字节变成了140个字节，因为缓冲队列还有60个字节没被应用拿走。

因此，接收端会在ACK的报文首部带上缩小后的滑动窗口140字节，发送端对应地调整发送窗口的大小为140字节。

此时对于发送端而言，已经发送并且确认的部分增加40字节，也就是SND、UNA右移40个字节，同时发送窗口缩小为140字节。



## TCP的拥塞控制

上面的流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络环境特别差，容易丢包，那么发送端就应该注意一些。这正是拥塞控制需要注意处理的问题。

对于拥塞控制来说，TCP每条链接都需要维护两个核心状态：

*   拥塞窗口（cwnd）
*   慢启动阈值(ssthesh)

涉及到的算法有这几个:

*   慢启动
*   拥塞避免
*   快速重传和快速回复

先从拥塞窗口说起

### 拥塞窗口

拥塞窗口是指目前自己还能传输的数据量大小。

那么之前介绍了接收窗口的概念，两者有什么区别？

*   接收窗口时接收端给的限制
*   拥塞窗口时发送端给的限制

限制的是发送窗口的大小。

有了这两个窗口，就可以计算发送窗口：

```
发送窗口大小=min(rwnd,cwnd)
```

取两者的较小值。而拥塞控制，就是来控制cwnd的变化。

### 慢启动

刚开始进入传输数据的时候，不知道现在的网络到底是稳定还是拥堵的，如果做的 太激进，疯狂丢包，会造成雪崩式的网络灾难。

因此，拥塞控制首先就是要采用一种保守的算法来适应整个网络，这种算法叫慢启动。运作过程如下：

*   首先，三次握手，双方宣告自己接收窗口大小。
*   双方初始化自己的拥塞窗口大小。
*   在开始传输的 一段时间，发送端每收到一个ACK，拥塞窗口大小加1，也就是说，每经过一个RTT，cwnd翻倍。

当然，他也不可能无止境的翻倍下去。他的阈值叫做慢启动阈值，当cwnd到达这个阈值后，就来控制cwnd的大小，这就涉及到拥塞避免。

### 拥塞避免

原来每收到一个ACK，cwnd加1，现在到达阈值了，cwnd只能加这么一点：1/cwnd。这样，得收到cwnd个ACK，最后拥塞窗口的大小cwnd总共才增加1.

所以，慢启动和拥塞避免是一起起作用的，是一体的。

### 快速重传和快速恢复

**快速重传**

在TCP传输过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的ACK。

比如，第5个包丢了，即使第6、7个包到达的接收端，接收端也一律返回第四个包的ACK。当发送端收到3个重复的ACK时，意识丢包了，于是马上进行重传，不用等到一个RTO的时间到了才重传。

这就是快速重传，他解决的是是否需要重传的问题。



### 选择性重传

在收到发送端的报文后，接收端回复一个ACK报文，那麽在这个报文的首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第5个包丢包了，当收到第6、7个包之后，接收端依然会告诉发送端，这两个包到了。剩下第5个包没到，就重传这个包。这个重传过程叫选择性重传（SACK）.

### 快速恢复

当然，发送端收到三次重复ACK之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。

在这个阶段，发送端如下改变：

*   拥塞阈值降低为cwnd的一半。
*   cwnd的大小变为拥塞阈值
*   cwnd线性增加。



## Nagle算法和延迟确认

### Nagle算法

试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。

而避免小包频繁发送，就是Nagle算法要做的事。

具体来说，Nagle算法的规则如下：

*   当第一次发送数据时不用等待，就算是1byte的小包也立即发送

*   后面发送满足下面条件之一就可以发了。

    *   数据包大小达到最大段大小(Max Segment Size, 即 MSS)
    *   之前所有包的 ACK 都已接收到

    *   ### 延迟确认

试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？

延迟确认所做的事情，就是后者，稍稍延迟，然后合并ACK，最后才回复给发送端。TCP要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。

不过需要注意的是，有一些场景是不能延迟确认的，收到了就要忙上回复：

*   接收到了大于一个frame的报文，且需要调整窗口的大小。
*   TCP处于quickack模式
*   发现了乱序包

两者一起使用，前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。

## TCP的keep-alive

大家都听说过 http 的`keep-alive`, 不过 TCP 层面也是有`keep-alive`机制，而且跟应用层不太一样。

试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。

这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。

在 Linux 下，可以这样查看相关的配置:

```
sudo sysctl -a | grep keepalive
// 每隔 7200 s 检测一次
net.ipv4.tcp_keepalive_time = 7200
// 一次最多重传 9 个包
net.ipv4.tcp_keepalive_probes = 9
// 每个包的间隔重传间隔 75 s
net.ipv4.tcp_keepalive_intvl = 75
```

不过，现状是大部分的应用并没有默认开启 TCP 的`keep-alive`选项，为什么？

站在应用的角度:

*   7200s 也就是两个小时检测一次，时间太长
*   时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接

因此是一个比较尴尬的设计。